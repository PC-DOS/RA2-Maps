SCP-EQ-Tools_generic_scripted_effects_delete_all_units = {
    every_possible_country = {
        recall_volunteers_from = PREV
    }
    delete_unit = {
        disband = no
    }
}

SCP-EQ-Tools_generic_scripted_effects_delete_all_enemy_units = {
    every_enemy_country = {
        SCP-EQ-Tools_generic_scripted_effects_delete_all_units = yes
    }
}

# Parameter 1: temp_param_new_state_controller_tag
SCP-EQ-Tools_generic_scripted_effects_change_all_state_controller = {
    every_controlled_state = {
        set_state_controller_to = var:temp_param_new_state_controller_tag
    }
    # Check if there is still some provinces under current scope's control
    # See https://hoi4.paradoxwikis.com/Data_structures#province_controllers
    for_each_loop = {
        array = global.province_controllers
        value = temp_current_province_controller
        index = temp_current_province_id
        
        if = {
            limit = {
                check_variable = { temp_current_province_controller = THIS }
            }
            var:temp_param_new_state_controller_tag = {
                set_province_controller = var:temp_current_province_id
            }
        }
    }
}

SCP-EQ-Tools_generic_scripted_effects_control_all_enemy_controlled_states = {
    every_enemy_country = {
        set_temp_variable = { temp_param_new_state_controller_tag = PREV }
        SCP-EQ-Tools_generic_scripted_effects_change_all_state_controller = yes
    }
}

# Parameter 1: temp_param_state_population_change_percentage
SCP-EQ-Tools_generic_scripted_effects_change_state_population_by_percentage = {
    set_temp_variable = { temp_current_state_population_change = state_population_k }
    multiply_temp_variable = { temp_current_state_population_change = temp_param_state_population_change_percentage }
    # Avoid overflow at ~2M
    if = {
        limit = {
            check_variable = { temp_param_state_population_change_percentage < 0 }
            OR = {
                # Will overflow after multiplied by 1000 (2000 * 1000 = 2000000)
                check_variable = { temp_current_state_population_change < -2000 }
                # Already overflown
                check_variable = { temp_current_state_population_change > 0 }
            }
        }
        set_temp_variable = { temp_current_state_population_change = -2000 }
    }
    else_if = {
        limit = {
            check_variable = { temp_param_state_population_change_percentage > 0 }
            OR = {
                # Will overflow after multiplied by 1000 (2000 * 1000 = 2000000)
                check_variable = { temp_current_state_population_change > 2000 }
                # Already overflown
                check_variable = { temp_current_state_population_change < 0 }
            }
        }
        set_temp_variable = { temp_current_state_population_change = 2000 }
    }
    multiply_temp_variable = { temp_current_state_population_change = 1000 }
    add_manpower = temp_current_state_population_change
    
    # Avoid adding manpower side effect, see https://hoi4.paradoxwikis.com/Effect#General_3
    if = {
        limit = {
            check_variable = { temp_current_state_population_change < 0 }
        }
        controller = {
            add_manpower = temp_current_state_population_change
        }
    }
}

# Parameter 1: temp_param_nuke_target_tag
# Parameter 2: temp_param_nuke_sender_tag
# Parameter 3: temp_param_nuke_target_state
# Parameter 4: temp_param_is_advanced_nuking_enabled
SCP-EQ-Tools_generic_scripted_effects_nuke_specified_state = {
    var:temp_param_nuke_target_state = {
        set_temp_variable = { temp_nuke_target_state = THIS }
        log = "Nuking state: [?temp_nuke_target_state.GetID] ([?temp_nuke_target_state.GetName])"
        var:temp_param_nuke_sender_tag = {
            launch_nuke = {
                state = temp_nuke_target_state
                controller = var:temp_param_nuke_sender_tag
                use_nuke = no
            }
        }
        if = {
            limit = {
                check_variable = { temp_param_is_advanced_nuking_enabled > 0 }
            }
            # Go hell with your Showa bullshit, JAPs!
            # Delete all units immediately
            var:temp_param_nuke_target_tag = {
                delete_unit = {
                    state = PREV
                    disband = no
                }
            }
            # Kills local people by percentage
            set_temp_variable = { temp_param_state_population_change_percentage = -0.5 }
            SCP-EQ-Tools_generic_scripted_effects_change_state_population_by_percentage = yes
            # Ensure minimal killing
            add_manpower = -24500
            var:temp_param_nuke_target_tag = {
                add_manpower = -24500
            }
            # Avoid killing all
            # Leave at least 1 person for the target state
            # If you killed all pupulation of the target state, the state's population will revert to manpower defined in history/states after save-load sequence
            if = {
                limit = {
                    state_population_k < 0.001
                    state_population < 1
                }
                add_manpower = 1
            }
            # If nuking target is capital and population is really low, kills country leader
            if = {
                limit = {
                    is_capital = yes
                    state_population_k < 0.245
                }
                # Go hell you Showa shit-ass
                var:temp_param_nuke_target_tag = {
                    kill_country_leader = yes
                }
            }
            # Marks the state and current controller as "nuked" for further "radiation" effect
            # Radiation will fade out after specified days, please refer to on_actions for details
            # Ref. https://hoi4.paradoxwikis.com/Effect#add_province_modifier
            # Radiation accumulation
            if = {
                limit = {
                    has_state_flag = SCP-EQ-Tools_generic_scripted_effects_nuke_specified_state_is_this_state_nuked
                }
                add_to_variable = { SCP-EQ-Tools_generic_scripted_effects_nuke_specified_state_current_state_radiation_level = 1 }
            }
            else = {
                set_variable = { SCP-EQ-Tools_generic_scripted_effects_nuke_specified_state_current_state_radiation_level = 1 }
            }
            # ParadoxWiki says add_province_modifier can have "days" attribution in province = {} scope, but it is not recognized in HoI4 1.14.10
            # Thus I have to use monthly on_actions
            clr_state_flag = SCP-EQ-Tools_generic_scripted_effects_nuke_specified_state_is_this_state_nuked
            set_state_flag = SCP-EQ-Tools_generic_scripted_effects_nuke_specified_state_is_this_state_nuked
            controller = {
                clr_country_flag = SCP-EQ-Tools_generic_scripted_effects_nuke_specified_state_is_this_country_nuked
                set_country_flag = SCP-EQ-Tools_generic_scripted_effects_nuke_specified_state_is_this_country_nuked
            }
            # Long-term damage due to radiation
            add_province_modifier = {
                static_modifiers = { SCP-EQ-Tools_province_modifiers_nuked_modifier }
                province = {
                    all_provinces = yes
                    #days = 730
                }
            }
        }
    }
}

# Parameter 1: temp_param_nuke_target_tag
# Parameter 2: temp_param_nuke_sender_tag
# Parameter 3: temp_param_is_every_province_nuked
# Parameter 4: temp_param_is_advanced_nuking_enabled
SCP-EQ-Tools_generic_scripted_effects_nuke_all_controlled_states = {
    log = "Nuking country: [?temp_param_nuke_target_tag.GetTag] ([?temp_param_nuke_target_tag.GetName])"
    
    # Nuke every state
    var:temp_param_nuke_target_tag = {
        every_controlled_state = {
            set_temp_variable = { temp_param_nuke_target_state = THIS }
            log = "Nuking state: [?temp_param_nuke_target_state.GetID] ([?temp_param_nuke_target_state.GetName])"
            SCP-EQ-Tools_generic_scripted_effects_nuke_specified_state = yes
        }
    }
    
    # Check if we need to nuke every province
    if = {
        limit = {
            check_variable = { temp_param_is_every_province_nuked > 0 }
        }
        for_each_loop = {
            array = province_controllers
            value = temp_current_province_controller
            index = temp_current_province_id
            
            if = {
                limit = {
                    check_variable = { temp_current_province_controller = temp_param_nuke_target_tag }
                }
                var:temp_param_nuke_sender_tag = {
                    launch_nuke = {
                        province = var:temp_current_province_id
                        use_nuke = no
                    }
                }
            }
        }
    }
}

# Parameter 1: temp_param_arr_teleporting_start_states
# Parameter 2: temp_param_arr_teleporting_target_states
# Parameter 3: temp_param_army_owner_types_to_be_teleported
#     0 - Any owner
#     1 - Armies owned by the scope who calls this scripted effect
#     2 - Armies owned by the scope who calls this scripted effect and all of its allies
#     3 - Armies owned ROOT scope
#     4 - Armies owned ROOT scope and all of its allies
SCP-EQ-Tools_generic_scripted_effects_teleport_armies = {
    set_temp_variable = { temp_current_caller_country = THIS }
    
    # Caller takes control of teleporting targets
    # You can only teleport armies to states controlled by yourself or faction members (please note that military access or volunteer sending is is not considered), thus we will set state controller before teleporting
    for_each_scope_loop = {
        array = temp_param_arr_teleporting_target_states
        
        # Check caller country's relationship with the controller of current scope (state)
        if = {
            # Case 1: Caller having war with this state's controller
            limit = {
                controller = {
                    has_war_with = var:temp_current_caller_country
                }
            }
            controller = {
                delete_unit = {
                    state = PREV
                    disband = no
                }
            }
            set_state_controller_to = var:temp_current_caller_country
        }
        else_if = {
            # Case 2: Caller is in peace with this state's controller, and the controller is not caller's ally, nor caller have military access to the controller
            limit = {
                controller = {
                    NOT = { tag = var:temp_current_caller_country }
                    NOT = { is_ally_with = var:temp_current_caller_country }
                    NOT = { is_in_faction_with = var:temp_current_caller_country }
                    NOT = { is_puppet_of = var:temp_current_caller_country }
                    NOT = { is_subject_of = var:temp_current_caller_country }
                }
            }
            controller = {
                delete_unit = {
                    state = PREV
                    disband = no
                }
            }
            transfer_state_to = var:temp_current_caller_country
        }
    }
        
    # Teleporting armies
    for_each_scope_loop = {
        array = temp_param_arr_teleporting_start_states
        
        # Print debug information
        #for_each_loop = {
        #    array = temp_param_arr_teleporting_target_states
        #    value = temp_teleporting_target
        #    
        #    log = "Teleporting armies from [?THIS.GetName] to [?temp_teleporting_target.GetName]"
        #}
        
        # Choose teleporting method
        if = {
            limit = { check_variable = { temp_param_army_owner_types_to_be_teleported = 0 } }
            teleport_armies = {
                to_state_array = temp_param_arr_teleporting_target_states
            }
        }
        else_if = {
            limit = { check_variable = { temp_param_army_owner_types_to_be_teleported = 1 } }
            teleport_armies = {
                limit = {
                    tag = var:temp_current_caller_country
                }
                to_state_array = temp_param_arr_teleporting_target_states
            }
        }
        else_if = {
            limit = { check_variable = { temp_param_army_owner_types_to_be_teleported = 2 } }
            teleport_armies = {
                limit = {
                    OR = {
                        tag = var:temp_current_caller_country
                        is_ally_with = var:temp_current_caller_country
                        is_in_faction_with = var:temp_current_caller_country
                        is_puppet_of = var:temp_current_caller_country
                        is_subject_of = var:temp_current_caller_country
                    }
                }
                to_state_array = temp_param_arr_teleporting_target_states
            }
        }
        else_if = {
            limit = { check_variable = { temp_param_army_owner_types_to_be_teleported = 3 } }
            teleport_armies = {
                limit = {
                    tag = ROOT
                }
                to_state_array = temp_param_arr_teleporting_target_states
            }
        }
        else_if = {
            limit = { check_variable = { temp_param_army_owner_types_to_be_teleported = 4 } }
            teleport_armies = {
                limit = {
                    OR = {
                        tag = ROOT
                        is_ally_with = ROOT
                        is_in_faction_with = ROOT
                        is_puppet_of = ROOT
                        is_subject_of = ROOT
                    }
                }
                to_state_array = temp_param_arr_teleporting_target_states
            }
        }
        else = {
            teleport_armies = {
                to_state_array = temp_param_arr_teleporting_target_states
            }
        }
    }
}